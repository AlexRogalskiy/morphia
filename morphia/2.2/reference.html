<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Morphia Docs</title>
    <meta name="generator" content="Antora 2.3.3">
<link rel="stylesheet" href="../../_/css/site.css">
<link rel="stylesheet" href="../../_/css/morphia.css">

  </head>
  <body class="article">
<header class="header" role="banner">
    <nav class="navbar">
        <div class="navbar-brand">
            <img height="80%" src="../../_/img/logo.png">
        </div>
        <div class="navbar-brand">
            <div class="navbar-item">
                <a href="https://morphia.dev">Morphia</a>
                <span class="separator">//</span>
                <a href="../..">Docs</a>
            </div>
            <button class="navbar-burger" data-target="topbar-nav">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <div class="navbar-item has-dropdown is-hoverable">
                    <div class="navbar-link">Projects</div>
                    <div class="navbar-dropdown">
                        <div class="navbar-item"><strong>Core</strong></div>
                        <a class="navbar-item" href="https://github.com/MorphiaOrg/morphia">Repository</a>
                        <a class="navbar-item" href="https://github.com/MorphiaOrg/morphia/issues">Issue Tracker</a>
                        <hr class="navbar-divider">
                        <div class="navbar-item"><strong>Critter</strong></div>
                        <a class="navbar-item" href="https://github.com/MorphiaOrg/critter">Repository</a>
                        <a class="navbar-item" href="https://github.com/MorphiaOrg/critter/issues">Issue Tracker</a>
                        <!--                        <hr class="navbar-divider">-->
                        <!--                        <a class="navbar-item" href="https://github.com/MorphiaOrg/morphia/blob/master/contributing.adoc">Contributing</a></div>-->
                    </div>
                </div>

                <div class="navbar-item has-dropdown is-hoverable">
                    <div class="navbar-link">Community</div>
                    <div class="navbar-dropdown is-right">
                        <a class="navbar-item" href="https://developer.mongodb.com/community/forums/c/drivers-odms/">Drivers &
                            ODMs chat</a>
                    </div>
                </div>

                <a class="navbar-item" href="https://twitter.com/evanchooly">
                    <span class="icon">
                        <svg aria-hidden="true" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                            <path fill="#57aaee"
                                  d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
                        </svg>
                    </span>
                </a>
            </div>
        </div>
    </nav>
</header>

<div class="body">
<div class="nav-container" data-component="morphia" data-version="2.2">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Morphia</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="quicktour.html">Quick Tour</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="reference.html">Reference</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="issues-help.html">Issues &amp; Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="javadoc/index.html">Javadoc</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Morphia</span>
    <span class="version">2.2-SNAPSHOT</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Critter</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../critter/4/index.html">4</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../landing/index.html">landing</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">Morphia</span>
      <ul class="versions">
        <li class="version is-current">
          <a href="index.html">2.2-SNAPSHOT</a>
        </li>
        <li class="version is-latest">
          <a href="../2.1/index.html">2.1</a>
        </li>
        <li class="version">
          <a href="../2/index.html">2</a>
        </li>
        <li class="version">
          <a href="../1.6/index.html">1.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../landing/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Morphia</a></li>
    <li><a href="reference.html">Reference</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">2.2-SNAPSHOT</button>
  <div class="version-menu">
    <a class="version is-current" href="reference.html">2.2-SNAPSHOT</a>
    <a class="version is-missing" href="../2.1/index.html">2.1</a>
    <a class="version is-missing" href="../2/index.html">2</a>
    <a class="version is-missing" href="../1.6/index.html">1.6</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/MorphiaOrg/morphia/edit/master/docs/modules/ROOT/pages/reference.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<div class="sect1">
<h2 id="_mapping"><a class="anchor" href="#_mapping"></a>Mapping</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_classes"><a class="anchor" href="#_classes"></a>Classes</h3>
<div class="paragraph">
<p>Mapping is achieved through one of two annotations to start:  <a href="javadoc/dev/morphia/annotations/Entity.html" class="page">@Entity</a> and
<a href="javadoc/dev/morphia/annotations/Embedded.html" class="page">@Embedded</a>.
In order for Morphia to consider any type for mapping, it must have one of these two annotation.  <code>@Entity</code> is used to denote a "top level" type.
These types tend to have their own collections whose names can be mapped via the <code>value</code> parameter.
Leaving this value blank will leave Morphia free to compute the collection name as defined by the collection naming strategy defined in <a href="javadoc/dev/morphia/mapping/MapperOptions.html" class="page">@MapperOptions</a>.
That default is currently the camel case value of the class&#8217;s simple name.
For example, to map a <code>UserProfile</code> entity under this strategy, the collection name would be mapped to <code>userProfile</code>.</p>
</div>
<div class="paragraph">
<p>Any type annotated with <code>@Entity</code> must have a field annotated with <a href="javadoc/dev/morphia/annotations/Id.html" class="page">@Id</a>.
The type of the field can be any type so long as Morphia or the driver have codecs that can map the data to and from mongodb.
When mapping an entity, one can also define <a href="#_indexing">indexes</a> and <a href="#_schema_validation">schema validations</a> as part of the entity declaration as well.</p>
</div>
<div class="sect3">
<h4 id="_constructors"><a class="anchor" href="#_constructors"></a>Constructors</h4>
<div class="paragraph">
<p>Morphia has traditionally required a 0-argument constructor on any mapped entity.
In fact, Morphia still prefers to use such a constructor should one be available.
However, as of 2.1, Morphia can also make use of another constructor that meets certain criteria:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The number of arguments in the constructor must match the number of fields on the class.
That is, every field must be represented in the constructor signature.</p>
</li>
<li>
<p>The names of the arguments must match the names of the fields.
Here, there is a bit of flexibility.
The argument name can match either the field name as found in the source or the mapped name as determined by any <code>@Property</code> annotation.
While this is likely to be the most common case as it is the simplest, for various this won&#8217;t always be possible or preferable.
If a constructor argument name can&#8217;t mirror the field name, using the <a href="#javadoc:dev/morphia/annotations/Name.html" class="page unresolved">@Name</a> annotation, an explict name can be given so that the argument can be properly matched to a field.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Changing the mapping configuration can interfere with Morphia&#8217;s ability to map arguments and fields so be careful when making changes to such things as the default field naming strategy or <a href="javadoc/dev/morphia/annotations/Property.html" class="page"><code>@Property</code></a> definitions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this mapping to take place, the source must be compiled to include the parameters in the generated bytecode.
With <code>javac</code> this is typically already configured by default.
However, Kotlin users will likely need to configure their builds to include the appropriate option.
For maven users, it&#8217;s as simple as adding one line to the Kotlin maven plugin <code>&lt;configuration&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;javaParameters&gt;true&lt;/javaParameters&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_external_types"><a class="anchor" href="#_external_types"></a>External types</h3>
<div class="paragraph">
<p>Some times persisted types come from external libraries whose source is either unavailable or simply can&#8217;t be modified.
Using these types would be impossible give then annotation requirements as stated above.
Morphia 2.1 introduced a new experimental API that loosens these restrictions a bit.
Using <a href="javadoc/dev/morphia/mapping/Mapper.html#mapExternal#(A,java.lang.Class)" class="page">Mapper#mapExternal</a> these external types can be passed in for use as embedded types in other entities.
An optional instance of <code>@Embedded</code> can created using the
<a href="javadoc/dev/morphia/annotations/experimental/EmbeddedBuilder.html" class="page">EmbeddedBuilder</a>.
A null can be passed in to simply accept the default values.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This API is experimental and is likely to shift a bit as it sees usage and feedback from the community.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_versioning"><a class="anchor" href="#_versioning"></a>Versioning</h3>
<div class="paragraph">
<p>Entities can be versioned to ensure that changes are applied serially and that no other processes are modifying an object in between the time it&#8217;s fetched, modified, and written back to the database.
To achieve this, simply add a field to a type, it can be a <code>long</code> or a
<code>Long</code>, and annotate that field with <a href="javadoc/dev/morphia/annotations/Version.html" class="page">@Version</a>.
This field must not be initialized to anything other than zero or null, however.
Morphia will take care of the rest.
If an object is fetched and another process updates the corresponding document in the database before it can be persisted back, an exception will be thrown when the write is attempted.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fields"><a class="anchor" href="#_fields"></a>Fields</h3>
<div class="paragraph">
<p>By default, any non-static field on a mapped class will be processed for persistence.
If a field is to be excluded from the mapping, it can be decorated with the <code>transient</code> keyword, annotated with  <a href="javadoc/dev/morphia/annotations/Transient.html" class="page">@Transient</a>, or with the <code>java.beans.Transient</code> annotation.
Otherwise all fields will be included that are defined on the mapped class and any super type.
However, Morphia will ignore fields in any super types found in <code>java*</code> packages which includes the standard JDK classes and the Java EE APIs.</p>
</div>
<div class="paragraph">
<p>There are times when it is necessary to modify a field mapping&#8217;s name, e.g. Using the
<a href="javadoc/dev/morphia/annotations/Property.html" class="page">@Property</a> annotation, a new name can be defined that will be used when writing to and reading from the database.
During a schema evolution, it is possible to load a field from an old name as well using the
<a href="javadoc/dev/morphia/annotations/AlsoLoad.html" class="page">@AlsoLoad</a> annotation.
Using this annotation, multiple old names can be used to find a field&#8217;s value in a returned document from query.
However, only the field&#8217;s name or the value specified in the <code>@Property</code>
annotation will be used when writing documents back to the database.
Similarly, if data is only intended to be loaded from the database but never written back, that field can be annotated with <a href="javadoc/dev/morphia/annotations/LoadOnly.html" class="page">@LoadOnly</a></p>
</div>
<div class="paragraph">
<p>If you do not specify a name via <code>@Property</code>, the default field naming strategy will be used.
The default strategy is to use the field&#8217;s name as defined in the source.
This strategy can be changed globally via the field naming strategy option on
<a href="javadoc/dev/morphia/mapping/MapperOptions.html" class="page">@MapperOptions</a>.
Simple indexes can be defined on a field if all that is needed for the index is a single field.
This can be done via the <a href="javadoc/dev/morphia/annotations/Indexed.html" class="page">@Indexed</a> annotation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_queries"><a class="anchor" href="#_queries"></a>Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia provides <a href="javadoc/dev/morphia/query/Query.html" class="page"><code>Query&lt;T&gt;</code></a> class to build a query and map the results back to instances of your entity classes and attempts to provide as much type safety and validation as possible.
To create the <code>Query</code>, we invoke the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Query&lt;Product&gt; query = datastore.find(Product.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>find()</code> returns an instance of <code>Query</code> which we can use to build a query.</p>
</div>
<div class="sect2">
<h3 id="_filter"><a class="anchor" href="#_filter"></a><code>filter()</code></h3>
<div class="paragraph">
<p>The most significant method <code>filter(Filter&#8230;&#8203;)</code>.
This method takes a number of filters to apply to the query being built.
The filters are added to any existing, previously defined filters so you needn&#8217;t add them all at once.
There are dozens of filters predefined in Morphia and can be found in the <code>dev.morphia.query.experimental.filters</code> package.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The package is currently <code>experimental</code>.
This done to signify that this API is a new one and might change based on user feedback prior to a final release.
It is expected that the API will be largely the same in the final release and you are highly encouraged to try it out before then.
If you encounter and bugs or usability issues, please file an
<a href="https://github.com/MorphiaOrg/morphia/issues">issue</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The filters can be accessed via the <a href="javadoc/dev/morphia/query/experimental/filters/Filters.html" class="page">Filters</a> class.
The method names largely match the operation name you would use querying via the mongo shell so this should help you translate queries in to Morphia&#8217;s API. For example, to query for products whose prices is greater than or equal to 1000, you would write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">query.filter(Filters.gte("price", 1000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will append the new criteria to any existing criteria already defined.
You can define as many filters in one call as you&#8217;d like or you may choose to append them in smaller groups based on whatever query building logic your application might have.</p>
</div>
</div>
<div class="sect2">
<h3 id="_complex_queries"><a class="anchor" href="#_complex_queries"></a>Complex Queries</h3>
<div class="paragraph">
<p>Of course, queries are usually more complex than single field comparisons.
Morphia offers both <code>and()</code> and <code>or()</code> to build up more complex queries.
An <code>and</code> query might look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">q.filter(and(
    eq("width", 10),
    eq("height", 1)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>or</code> clause looks exactly the same except for using <code>or()</code> instead of <code>and()</code>, of course.
The default is to "and" filter criteria together so if all you need is an <code>and</code> clause, you don&#8217;t need an explicit call to <code>and()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.find(UserLocation.class)
    .filter(
        lt("x", 5),
        gt("y", 4),
        gt("z", 10));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This generates an implicit <code>and</code> across the field comparisons.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_query_options"><a class="anchor" href="#_other_query_options"></a>Other Query Options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is more to querying than simply filtering against different document values.
Listed below are some of the options for modifying the query results in different ways.</p>
</div>
<div class="sect2">
<h3 id="_projections"><a class="anchor" href="#_projections"></a>Projections</h3>
<div class="paragraph">
<p><a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/">Projections</a> allow you to return only a subset of the fields in a document.
This is useful when you need to only return a smaller view of a larger object.
Borrowing from the
<a href="https://github.com/MorphiaOrg/morphia/blob/master/morphia/src/test/java/dev/morphia/TestQuery.java">unit tests</a>, this is an example of this feature in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ContainsRenamedFields user = new ContainsRenamedFields("Frank", "Zappa");
datastore.save(user);

ContainsRenamedFields found = datastore
                                  .find(ContainsRenamedFields.class)
                                  .iterator(new FindOptions()
                                               .projection().include("first_name")
                                               .limit(1))
                                  .tryNext();
assertNotNull(found.firstName);
assertNull(found.lastName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see here, we&#8217;re saving this entity with a first and last name but our query only returns the first name (and the <code>_id</code> value) in the returned instance of our type.
It&#8217;s also worth noting that this projection works with both the mapped document field name
<code>"first_name"</code> and the Java field name <code>"firstName"</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While projections can be a nice performance win in some cases, it&#8217;s important to note that this object can not be safely saved back to MongoDB. Any fields in the existing document in the database that are missing from the entity will be removed if this entity is saved.
For example, in the example above if <code>found</code> is saved back to MongoDB, the <code>last_name</code> field that currently exists in the database for this entity will be removed.
To save such instances back consider using
<a href="javadoc/dev/morphia/Datastore.html#merge(T)#" class="page"><code>Datastore#merge(T)</code></a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_limiting_and_skipping"><a class="anchor" href="#_limiting_and_skipping"></a>Limiting and Skipping</h3>
<div class="paragraph">
<p>Pagination of query results is often done as a combination of skips and limits.
Morphia offers <code>FindOptions.limit(int)</code> and
<code>FindOptions.offset(int)</code> for these cases.
An example of these methods in action would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.find(Person.class)
    .iterator(new FindOptions()
	    .offset(1)
	    .limit(10))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query will skip the first element and take up to the next 10 items found by the query.
There&#8217;s a caveat to using skip/limit for pagination, however.
See the <a href="http://docs.mongodb.org/manual/reference/method/cursor.skip">skip</a> documentation for more detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordering"><a class="anchor" href="#_ordering"></a>Ordering</h3>
<div class="paragraph">
<p>Ordering the results of a query is done via
<a href="javadoc/dev/morphia/query/FindOptions.html#sort(dev.morphia.query.Sort&#8230;&#8203;)#" class="page"><code>FindOptions.sort(Sort&#8230;&#8203;)</code></a>, etc.
For example, to sort by <code>age</code> (youngest to oldest) and then <code>income</code> (highest to lowest), you would use this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">getDs().find(User.class)
       .iterator(new FindOptions()
                    .sort(ascending("age"), descending("income"))
                    .limit(1))
       .tryNext();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tailable_cursors"><a class="anchor" href="#_tailable_cursors"></a>Tailable Cursors</h3>
<div class="paragraph">
<p>If you have a <a href="http://docs.mongodb.org/manual/core/capped-collections/">capped collection</a> it&#8217;s possible to "tail" a query so that when new documents are added to the collection that match your query, they&#8217;ll be returned by the
<a href="http://docs.mongodb.org/manual/reference/glossary/#term-tailable-cursor">tailable cursor</a>.
An example of this feature in action can be found in the
<a href="https://github.com/MorphiaOrg/morphia/blob/master/morphia/src/test/java/dev/morphia/TestQuery.java">unit tests</a> in the <code>testTailableCursors()</code> test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.getMapper().map(CappedPic.class);
getDs().ensureCaps();                                                          <i class="conum" data-value="1"></i><b>(1)</b>
final Query&lt;CappedPic&gt; query = getDs().find(CappedPic.class);
final List&lt;CappedPic&gt; found = new ArrayList&lt;&gt;();

final MorphiaCursor&lt;CappedPic&gt; tail =
    query.iterator(new FindOptions()
        .cursorType(CursorType.Tailable));
while(found.size() &lt; 10) {
	found.add(tail.next());                                                    <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two things to note about this code sample:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>This tells Morphia to make sure that any entity configured to use a capped collection has its collection created correctly.
If the collection already exists and is not capped, you will have to manually
<a href="http://docs.mongodb.org/manual/core/capped-collections/#convert-a-collection-to-capped">update</a> your collection to be a capped collection.</p>
</li>
<li>
<p>Since this <code>Iterator</code> is backed by a tailable cursor, <code>hasNext()</code> and <code>next()</code> will block until a new item is found.
In this version of the unit test, we tail the cursor waiting to pull out objects until we have 10 of them and then proceed with the rest of the application.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_updates"><a class="anchor" href="#_updates"></a>Updates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updates in 2.0, are issued using a <code>Query</code> instance . These update operations are executed on the server without fetching any documents across the wire.
Update operations are defined using a set of functions as defined on
<a href="javadoc/dev/morphia/query/experimental/updates/UpdateOperators.html" class="page">UpdateOperators</a>.
In our examples, we&#8217;ll be using the following model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity("hotels")
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   List&lt;Integer&gt; roomNumbers = new ArrayList&lt;Integer&gt;();

   // ... getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... getters and setters
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_setunset"><a class="anchor" href="#_setunset"></a>set()/unset()</h3>
<div class="paragraph">
<p>To change the name of the hotel, one would use something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .update(UpdateOperators.set("name", "Fairmont Chateau Laurier"))
    .execute();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>execute()</code> can optionally take <a href="javadoc/dev/morphia/UpdateOptions.html" class="page">UpdateOptions</a> if there are any options you might want to apply to your update statement.</p>
</div>
<div class="paragraph">
<p>Embedded documents are updated the same way.
To change the name of the city in the address, one would use something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .update(UpdateOperators.set("address.city", "Ottawa"))
    execute();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Values can also be removed from documents as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .update(UpdateOperators.unset("name"))
    execute();</code></pre>
</div>
</div>
<div class="paragraph">
<p>After this update, the name of the hotel would be <code>null</code> when the entity is loaded.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_updates"><a class="anchor" href="#_multiple_updates"></a>Multiple Updates</h3>
<div class="paragraph">
<p>By default, an update operation will only update the first document matching the query.
This behavior can be modified via the optional
<a href="javadoc/dev/morphia/UpdateOptions.html" class="page">UpdateOptions</a> parameter on <code>execute()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .inc("stars")
    .execute(new UpdateOptions()
        .multi(true));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_upserts"><a class="anchor" href="#_upserts"></a>Upserts</h3>
<div class="paragraph">
<p>In some cases, updates are issued against a query that might not match any documents.
In these cases, it&#8217;s often fine for those updates to simply pass with no effect.
In other cases, it&#8217;s desirable to create an initial document matching the query parameters.
Examples of this might include user high scores, e.g. In cases like this, we have the option to use an upsert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .filter(gt("stars", 100))
    .update()
    .execute(new UpdateOptions()
                     .upsert(true));

// creates { "_id" : ObjectId("4c60629d2f1200000000161d"), "stars" : 50 }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_checking_results"><a class="anchor" href="#_checking_results"></a>Checking results</h3>
<div class="paragraph">
<p>In all this one thing we haven&#8217;t really looked at is how to verify the results of an update.
The <code>execute()</code> method returns an instance of
<code>com.mongodb.client.result.UpdateResult</code>.
Using this class, you can get specific numbers from the update operation as well as any generated ID as the result of an upsert.</p>
</div>
</div>
<div class="sect2">
<h3 id="_returning_the_updated_entity"><a class="anchor" href="#_returning_the_updated_entity"></a>Returning the updated entity</h3>
<div class="paragraph">
<p>There are times when a document needs to be updated and also fetched from the database.
In the server documentation, this is referred to as <a href="http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/"><code>findAndModify</code></a>.
In Morphia, this functionality is exposed through the <a href="javadoc/dev/morphia/query/Query.html#modify(dev.morphia.query.experimental.updates.UpdateOperator, dev.morphia.query.experimental.updates.UpdateOperator&#8230;&#8203;)#" class="page">Query#modify()</a>
method.
With this method, you can choose to return the updated entity in either the state before or after the update.
The default is to return the entity in the <em>after</em> state.
This can be changed by passing in a <code>ModifyOptions</code> reference to the operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .modify(UpdateOperators.set("address.city", "Ottawa"))
    execute(new ModifyOptions()
        .returnDocument(ReturnDocument.BEFORE));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deletes"><a class="anchor" href="#_deletes"></a>Deletes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Queries are used to delete documents from the database as well.
Using
<a href="javadoc/dev/morphia/query/Query.html#delete()#" class="page"><code>Query#delete()</code></a>, we can delete documents matching the query.
The default operation will only delete the first matching document.
However, you can opt to delete all matches by passing in the appropriate options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore
    .find(Hotel.class)
    .filter(gt("stars", 100))
    .delete(new DeleteOptions()
                     .multi(true));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references"><a class="anchor" href="#_references"></a>References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia supports two styles of defining references: the <a href="javadoc/dev/morphia/annotations/Reference.html" class="page"><code>@Reference</code></a>
annotation and the experimental <a href="javadoc/dev/morphia/mapping/experimental/MorphiaReference.html" class="page"><code>MorphiaReference</code></a>.
The annotation based approach is discussed <a href="#_references#">here</a>.
This guide will cover the wrapper based approach.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This API is experimental.
Its implementation and API subject to change based on user feedback.
However, users are encouraged to experiment with the API and provide as much feedback as possible both positive and negative as this will likely be the approach used going forward.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An alternative to the traditional annotation-based approach is the
<a href="javadoc/dev/morphia/mapping/experimental/MorphiaReference.html" class="page"><code>MorphiaReference</code></a> wrapper.
This type can not be instantiated directly.
Instead a <code>wrap()</code> method is provided that will construct the proper type and track the necessary state.
Currently, four different types of values are supported by <code>wrap()</code>: a reference to a single entity, a List of references to entities, a Set, and a Map.  <code>wrap()</code>
will determine how best to handle the type passed and create the appropriate structures internally.
This is how this type might be used in practice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private class Author {
    @Id
    private ObjectId id;
    private String name;
    private MorphiaReference&lt;List&lt;Book&gt;&gt; list;
    private MorphiaReference&lt;Set&lt;Book&gt;&gt; set;
    private MorphiaReference&lt;Map&lt;String, Book&gt;&gt; map;

    public Author() { }

    public List&lt;Book&gt; getList() {
        return list.get();
    }

    public void setList( List&lt;Book&gt; list) {
        this.list = MorphiaReference.wrap(list);
    }

    public Set&lt;Book&gt; getSet() {
        return set.get();
    }

    public void setSet( Set&lt;Book&gt; set) {
        this.set = MorphiaReference.wrap(set);
    }

    public Map&lt;String, Book&gt; getMap() {
        return map.get();
    }

    public void setMap( Map&lt;String, Book&gt; map) {
        this.map = MorphiaReference.wrap(map);
    }
}

private class Book {
    @Id
    private ObjectId id;
    private String name;
    private MorphiaReference&lt;Author&gt; author;

    public Book() { }

    public Author getAuthor() {
        return author.get();
    }

    public void setAuthor( Author author) {
        this.author = MorphiaReference.wrap(author);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we have 3 different references from <code>Author</code> to <code>Book</code> and one in the opposite direction.
It would also be good to note that the public API of those two classes don&#8217;t expose the <code>MorphiaReference</code> externally.
This is, of course, a stylistic choice but is the encouraged approach as it avoids leaking out implementation and mapping details outside of your model.</p>
</div>
<div class="paragraph">
<p><code>setList()</code> accepts a <code>List&lt;Book&gt;</code> and stores them as references to <code>Book</code> instances stored in the collection as defined by the mapping metadata for <code>Book</code>.
Because these references point to the mapped collection name for the type, we can get away with storing only the <code>_id</code> fields for each book.
This gives us data in the database that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">&gt; db.Author.find().pretty()
{
	"_id" : ObjectId("5c3e99276a44c77dfc1b5dbd"),
	"className" : "dev.morphia.mapping.experimental.MorphiaReferenceTest$Author",
	"name" : "Jane Austen",
	"list" : [
		ObjectId("5c3e99276a44c77dfc1b5dbe"),
		ObjectId("5c3e99276a44c77dfc1b5dbf"),
		ObjectId("5c3e99276a44c77dfc1b5dc0"),
		ObjectId("5c3e99276a44c77dfc1b5dc1"),
		ObjectId("5c3e99276a44c77dfc1b5dc2")
	]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we only need to store the ID values because the collection is already known elsewhere.
However, sometimes we need to refer to documents stored in different collections.
For example, if the generic type of the reference is a parent interface or class, we sometimes need to store extra information.
For these cases, we store the references as full <code>DBRef</code> instances so we can track the appropriate collection for each reference.
Using this version, we get data in the database that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">&gt; db.jane.find().pretty()
{
	"_id" : ObjectId("5c3e99c06a44c77e5a9b5701"),
	"className" : "dev.morphia.mapping.experimental.MorphiaReferenceTest$Author",
	"name" : "Jane Austen",
	"list" : [
		DBRef("books", ObjectId("5c3e99c06a44c77e5a9b5702")),
		DBRef("books", ObjectId("5c3e99c16a44c77e5a9b5703")),
		DBRef("books", ObjectId("5c3e99c16a44c77e5a9b5704")),
		DBRef("books", ObjectId("5c3e99c16a44c77e5a9b5705")),
		DBRef("books", ObjectId("5c3e99c16a44c77e5a9b5706"))
	]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, we have a document field called <code>list</code> but as you can see in the second case, we&#8217;re not storing just the <code>_id</code> values but
<code>DBRef</code> instances storing both the collection name, "books" in this case, and <code>ObjectId</code> values from the Books.
This lets the wrapper properly reconstitute these references when you&#8217;re ready to use them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Before we go too much further, it&#8217;s important to point that, regardless of the type of the references, they are fetched lazily.
So if you multiple fields with referenced entities, they will not be fetched until you call <code>get()</code> on the <code>MorphiaReference</code>.
If the type is a <code>Collection</code> or a <code>Map</code>, all the referenced entities are fetched and loaded via a single query if possible.
This saves on server round trips but does raise the risk of potential <code>OutOfMemoryError</code> problems if you load too many objects in to memory this way.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>Set</code> of references will look no different in the database than the <code>List</code> does.
However, <code>Map`s of references are slightly more
complicated.  A `Map</code> might look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">&gt; db.Author.find().pretty()
{
	"_id" : ObjectId("5c3e9cad6a44c77fa8f38f58"),
	"className" : "dev.morphia.mapping.experimental.MorphiaReferenceTest$Author",
	"name" : "Jane Austen",
	"map" : {
		"Sense and Sensibility " : ObjectId("5c3e9cad6a44c77fa8f38f59"),
		"Pride and Prejudice" : ObjectId("5c3e9cad6a44c77fa8f38f5a"),
		"Mansfield Park" : ObjectId("5c3e9cad6a44c77fa8f38f5b"),
		"Emma" : ObjectId("5c3e9cad6a44c77fa8f38f5c"),
		"Northanger Abbey" : ObjectId("5c3e9cad6a44c77fa8f38f5d")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>References to single entities will follow the same pattern with regards to the <code>_id</code> values vs <code>DBRef</code> entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Currently there is no support for configuring the <code>ignoreMissing</code> parameter as there is via the annotation.
The wrapper will silently drop missing ID values or return null depending on the type of the reference.
Depending on the response to this feature in generalconsideration can be given to adding such functionality in the future.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aggregations"><a class="anchor" href="#_aggregations"></a>Aggregations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="http://docs.mongodb.org/manual/aggregation">aggregation framework</a> in MongoDB allows you to define a series (called a pipeline) of operations (called stages) against the data in a collection.
These pipelines can be used for analytics or they can be used to convert your data from one form to another.
This guide will not go in to the details of how aggregation works, however.
The official MongoDB <a href="http://docs.mongodb.org/manual/aggregation">documentation</a> has extensive tutorials on such details.
Rather, this guide will focus on the Morphia API. The examples shown here are taken from the
<a href="https://github.com/MorphiaOrg/morphia/blob/master/morphia/src/test/java/dev/morphia/aggregation/AggregationTest.java">tests</a> in Morphia itself.</p>
</div>
<div class="paragraph">
<p>Writing an aggregation pipeline starts just like writing a standard query.
As with querying, we start with the <code>Datastore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MorphiaCursor&lt;Author&gt; aggregate = getDs().aggregate(Book.class)
     .group(of(id("author"))
                .field("books", push(field("title"))))
     .sort(Sort.on().ascending("name"))
     .execute(Author.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>aggregate()</code> takes a <code>Class</code> literal.
This lets Morphia know which collection to perform this aggregation against.
Because of the transformational operations available in the aggregation <a href="http://docs.mongodb.org/manual/core/aggregation-pipeline">pipeline</a>, Morphia can not validate as much as it can with querying so care will need to be taken to ensure document fields actually exist when referencing them in your pipeline.</p>
</div>
<div class="sect2">
<h3 id="_the_pipeline"><a class="anchor" href="#_the_pipeline"></a>The Pipeline</h3>
<div class="paragraph">
<p>Aggregation pipelines are comprised of a series stages.
Our example here has only one stage: <code>group()</code>.
This method is the Morphia equivalent of the <a href="http://docs.mongodb.org/manual/reference/operator/aggregation/group/"><code>$group</code></a> operator.
This stage, as the name suggests, groups together documents based on various criteria.
In this example, we are collecting together all the books by author.  <code>group()</code> takes one parameter: a <code>Group</code> instance.
This instance is created using the <code>Group.of()</code> method which will return a new <code>Group</code> stage instance.
There are a few overloads but the simplest version, <code>of()</code>, will generate a <code>$group</code> stage with no <code>_id</code>
field in the document.
In this case, we&#8217;re passing the output of the <code>id(String)</code> method which creates an <code>_id</code> field using the values found in the <code>author</code> properties found in the collection&#8217;s documents.</p>
</div>
<div class="paragraph">
<p>The next step defines a new field, <code>books</code> comprised of the titles of the books found in each document.
(For reference, this example is the Morphia equivalent of an <a href="http://docs.mongodb.org/manual/reference/operator/aggregation/group/#group-title-by-author">example</a> found in the aggregation tutorials.) This results in a series of documents that look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{ "_id" : "Homer", "books" : [ "The Odyssey", "Iliad" ] }
{ "_id" : "Dante", "books" : [ "The Banquet", "Divine Comedy", "Eclogues" ] }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_executing_the_pipeline"><a class="anchor" href="#_executing_the_pipeline"></a>Executing the Pipeline</h3>
<div class="paragraph">
<p>Once your pipeline is complete, you can execute it via the <code>execute()</code> method.
This method takes a <code>Class</code> reference for the target type of your aggregation.
Given this type, Morphia will map each document in the results and return it.
Additionally, you can also include some options to <code>execute()</code>.
We can use the various options on the
<a href="javadoc/dev/morphia/aggregation/experimental/AggregationOptions.html" class="page"><code>AggregationOptions</code></a> class to configure how we want the pipeline to execute.</p>
</div>
<div class="sect3">
<h4 id="_out"><a class="anchor" href="#_out"></a>$out</h4>
<div class="paragraph">
<p>Depending your use case, you might not watch to return the results of your aggregation but simply output them to another collection.
That&#8217;s where <code>$out</code> comes in.  <a href="http://docs.mongodb.org/manual/reference/operator/aggregation/out/"><code>$out</code></a> is an operator that allows the results of a pipeline to be stored in to a named collection.
This collection can not be sharded or a capped collection, however.
This collection, if it does not exist, will be created upon execution of the pipeline.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Any existing data in the collection will be replaced by the output of the aggregation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An example aggregation using the <code>$out</code> stage looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.aggregate(Book.class)
       .group(Group.of(id("author"))
                   .field("books", push()
                                       .single(field("title"))))
       .out(Out.to(Author.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll note that <code>out()</code> is the final method called here rather than <code>execute()</code>.
This is because <code>$out</code> must be the final stage in the pipeline and it simply makes no sense to do anything other than execute the pipeline at that point.
If you look at what we&#8217;re passing to the method, you&#8217;ll notice the <code>Out</code> class.
There are currently two methods of note on <code>Out</code>:  <code>to(Class)</code> and <code>to(String)</code>.
Using either of these methods instructs Morphia to write to either the collection mapped for the given <code>Class</code> or the named collection as noted by the String give.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may be wondering about the use of <code>Out</code> here and that it seems a bit overcomplicated.
One of the design goals for the 2.0 API is to simplify the overall API and to reduce the number of overloads through the introduction of parameter or options objects.
By limiting the <code>Aggregation</code> API to two methods for <code>$out</code> (the seconds takes an <code>AggregationOptions</code> reference), we can keep <code>Aggregation</code> itself slim and incorporate any future variations in <code>$out</code> limited to the <code>Out</code> class.
This should, hopefully, make both APIs easier to digest and evolve.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_merge"><a class="anchor" href="#_merge"></a>$merge</h4>
<div class="paragraph">
<p><a href="http://docs.mongodb.org/manual/reference/operator/aggregation/merge/"><code>$merge</code></a> is a very similar option with a some major differences.
The biggest difference is that <code>$merge</code> can write to existing collections without destroying the existing documents.  <code>$out</code> would obliterate any existing documents and replace them with the results of the pipeline.  <code>$merge</code>, however, can deposit these new results alongside existing data and update existing data.</p>
</div>
<div class="paragraph">
<p>Using <code>$merge</code> might look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.aggregate(Salary.class)
   .group(Group.of(id()
                       .field("fiscal_year")
                       .field("dept"))
               .field("salaries", sum(field("salary"))))
   .merge(Merge.into("budgets")
               .on("_id")
               .whenMatched(WhenMatched.REPLACE)
               .whenNotMatched(WhenNotMatched.INSERT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Much like <code>out()</code> above, for <code>merge()</code> we pass in a <code>Merge</code> reference as created by the <code>Merge.into()</code> method.
A merge is slightly more complex and so has more options to consider.
In this example, we&#8217;re merging in to the <code>budgets</code> collection and merging any existing documents based on the <code>_id</code> as denoted using the <code>on()</code> method.
Because there may be existing data in the collection, we need to instruct the operation how to handle those cases.
In this example, when documents matching we&#8217;re choosing to replace them and when they don&#8217;t we&#8217;re instructing the operation to insert the new documents in to the collection.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration"><a class="anchor" href="#_configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia 2.0 introduced a number of new ways to configure its behavior.
These values are listed below:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Collection naming</p>
</li>
<li>
<p>Property naming</p>
</li>
<li>
<p>The discriminator key</p>
</li>
<li>
<p>The discriminator value</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_collection_and_property_naming"><a class="anchor" href="#_collection_and_property_naming"></a>Collection and property naming</h3>
<div class="paragraph">
<p>Traditionally Morphia has used with the class&#8217;s "simple name" for the collection name if you choose to not manually map the name of an entity&#8217;s collection.
Similarly, an entity&#8217;s properties were named after the Java field name unless mapped otherwise with the
<code>@Property</code> annotation.
In 2.0, however, we define naming strategies.
As of 2.0, the naming strategies supported out of the box are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>identity</code> This is the legacy behavior Morphia has always used.</p>
</li>
<li>
<p><code>lower</code> This is simply the lower case form of the <code>identity</code> strategy.</p>
</li>
<li>
<p><code>snake</code> This transforms element names in to their [snake case](<a href="https://en.wikipedia.org/wiki/Snake_case" class="bare">https://en.wikipedia.org/wiki/Snake_case</a>) versions.
For those coming from a Python background or who work with Python developers regularly, this should look familiar.</p>
</li>
<li>
<p><code>camel</code> This transforms element names in to their [camel case](<a href="https://en.wikipedia.org/wiki/Camel_case" class="bare">https://en.wikipedia.org/wiki/Camel_case</a>) versions.
This is the form most java developers will be familiar with.</p>
</li>
<li>
<p><code>kebab</code> This transforms element names in to their [kebab case](<a href="https://en.wikipedia.org/wiki/Kebab_case" class="bare">https://en.wikipedia.org/wiki/Kebab_case</a>) versions.
This looks exactly like the <code>snake case</code> but with <code>-</code> instead of <code>_</code> so that it looks like it&#8217;s on a kebab skewer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These strategies can all be access via the <code>NamingStrategy</code> class via their named methods.
In the case where you have a custom naming strategy you&#8217;d like to employ, e.g., perhaps some hashing function to obscure element names, you can simply extend <code>NamingStrategy</code>
yourself and implement whatever logic you might need.</p>
</div>
</div>
<div class="sect2">
<h3 id="_discriminator_keys_and_values"><a class="anchor" href="#_discriminator_keys_and_values"></a>Discriminator keys and values</h3>
<div class="paragraph">
<p>Morphia has long hard coded the choice of how to encode an entity&#8217;s type in to the resulting documents in the database using the
<code>className</code> key and the simple name of the class.
As of 2.0, you have a choice to change that if you&#8217;d like.
The new default is to use
<code>_t</code> as the discriminator property key.
This was chosen in part because of its use in other systems and also for its brevity.
By default, Morphia 2.0 stores the entity type unless you configure your types otherwise so saving space seemed prudent.</p>
</div>
<div class="paragraph">
<p>Similar to how collections and fields have a naming strategy, we can apply a global function to determine the discriminator values should we choose.
The choices here are simpler:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>className()</code>/<code>lowerClassName()</code></p>
</li>
<li>
<p><code>simpleName()</code>/<code>lowerSimpleName()</code></p>
<div class="literalblock">
<div class="content">
<pre>These call all be accessed via their named methods on `DiscriminatorFunction` and just like the `NamingStrategy` cases if the provided
 options are not sufficient, you can implement your own by subclassing `DiscriminatorFunction` and implementing your own function.</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_old_versus_new"><a class="anchor" href="#_old_versus_new"></a>Old versus New</h3>
<div class="paragraph">
<p>Morphia can be configured in one of two ways: the legacy mode and the modern mode.</p>
</div>
<div class="sect3">
<h4 id="_legacy"><a class="anchor" href="#_legacy"></a>Legacy</h4>
<div class="paragraph">
<p>We&#8217;ll cover the legacy mode first as it reflects how Morphia worked prior to 2.0.  <code>MapperOptions</code> drives the configuration and so this is where we&#8217;ll start.
Prior to 2.0, you could simply create a <code>MapperOptions</code> instance directly.
Starting with 2.0, you will need to use one of the factory methods.
In this instance, you will want the <code>legacy()</code> method.
Among other things, this will configure Morphia to the legacy implementation of the <code>Query</code> class.
The <code>legacy()</code> builder currently configures the following settings:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>className</code> as the discriminator key</p>
</li>
<li>
<p><code>className()</code> as the <code>DiscriminatorFunction</code></p>
</li>
<li>
<p><code>identity()</code> as both the class and field name strategies</p>
</li>
<li>
<p>Configures the legacy query implementation</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_modern"><a class="anchor" href="#_modern"></a>Modern</h4>
<div class="paragraph">
<p>One of the big goals for 2.0 was to modernize both the API and behavior of Morphia.
As such, the <code>builder()</code> method returns a
<code>Builder</code> that applies some updated defaults:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>_t</code> as the new discriminator key (replacing <code>className</code>)</p>
</li>
<li>
<p><code>simpleName()</code> as the discriminator function used to determine these values</p>
</li>
<li>
<p><code>camelCase()</code> is the default collection naming strategy</p>
</li>
<li>
<p><code>identity()</code> remains the property naming strategy</p>
</li>
<li>
<p>A new <code>Query</code> implementation is configured enabling the new <code>Filters</code> based querying and disabling some older, deprecated methods.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_indexing"><a class="anchor" href="#_indexing"></a>Indexing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia provides annotations that allow developers to define indexes for a collection to be defined alongside the other mapping data on an entity&#8217;s source.
In addition to the familiar ascending/descending index types, Morphia and MongoDB support
<a href="http://docs.mongodb.org/manual/core/index-ttl/">TTL</a>, <a href="http://docs.mongodb.org/manual/core/index-text/">text</a>, and <a href="http://docs.mongodb.org/manual/applications/geospatial-indexes/">geospatial</a>
indexes.
When defining <a href="#_text_indexing">text indexes</a> there are certain restrictions which will be covered below.
Full details for all these types are available in the <a href="http://docs.mongodb.org/manual/indexes">manual</a>.</p>
</div>
<div class="paragraph">
<p>There are two ways to define indexes: at the class level and at the field level.</p>
</div>
<div class="sect2">
<h3 id="_class_level_indexes"><a class="anchor" href="#_class_level_indexes"></a>Class Level Indexes</h3>
<div class="paragraph">
<p>Class level indexing begins with the <a href="javadoc/dev/morphia/annotations/Indexes.html" class="page"><code>@Indexes</code></a> annotation.
This is a container annotation whose sole purpose is to hold a number of <a href="javadoc/dev/morphia/annotations/Index.html" class="page"><code>@Index</code></a> annotations.
This annotation has two primary components to cover here:  <code>fields</code> and <code>options</code>.
An index definition would take the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
@Indexes({
    @Index(fields = @Field(value = "field2", type = DESC)),
    @Index(
      fields = @Field("field3"),
      options = @IndexOptions(name = "indexing_test")
    )
})
public class IndexExample {
    @Id
    private ObjectId id;
    private String field;
    @Property
    private String field2;
    @Property("f3")
    private String field3;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fields_2"><a class="anchor" href="#_fields_2"></a>Fields</h3>
<div class="paragraph">
<p>Which fields to index are defined with the <a href="javadoc/dev/morphia/annotations/Field.html" class="page"><code>@Field</code></a> annotation.
An arbitrary number of <a href="javadoc/dev/morphia/annotations/Field.html" class="page"><code>@Field</code></a>s can be given but at least one must be present.
The name used for the field can be either the Java field name or the mapped document field name as defined in the class&#8217;s mapping via, e.g., the
<a href="javadoc/dev/morphia/annotations/Property.html" class="page"><code>@Property</code></a> or <a href="javadoc/dev/morphia/annotations/Embedded.html" class="page"><code>@Embedded</code></a>
annotations.
For most index types, this value is validated by default.
An exception is made for <a href="#_text_indexing">text indexing</a> as discussed below.</p>
</div>
</div>
<div class="sect2">
<h3 id="_index_options"><a class="anchor" href="#_index_options"></a>Index Options</h3>
<div class="paragraph">
<p>Options for an index are defined on the <a href="javadoc/dev/morphia/annotations/IndexOptions.html" class="page"><code>@IndexOptions</code></a>.
More complete documenation can be found in the <a href="http://docs.mongodb.org/manual/reference/method/db.collection.createIndex/#options">manual</a>.
Using the options allows you to run indexing in the background, e.g. By default, creating an index blocks all other operations on a database.
When building an index on a collection, the database that holds the collection is unavailable for read or write operations until the index build completes.
For potentially long running index building operations, consider the <strong>background</strong> operation so that the MongoDB database remains available during the index building operation.
The MongoDB <a href="http://docs.mongodb.org/manual/core/index-creation/#background-construction">manual</a> has more detail.</p>
</div>
<div class="paragraph">
<p>By default Morphia will attempt to validate the fields specified but in some cases that isn&#8217;t desirable so you can turn it off via the options refernce.  <code>IndexOptions</code> lets you define <a href="http://docs.mongodb.org/manual/core/index-ttl/">TTL</a>, <a href="http://docs.mongodb.org/manual/core/index-sparse/">sparse</a>, and <a href="http://docs.mongodb.org/manual/core/index-partial/">partial</a> indexes as well.  <code>IndexOptions</code> can also be used to give an index a more human friendly name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Whether user specified or MongoDB generated, index names including their full namespace (i.e. database.collection) cannot be longer than the <a href="http://docs.mongodb.org/manual/reference/limits/#Index-Name-Length">Index Name Limit</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_partial_indexes"><a class="anchor" href="#_partial_indexes"></a>Partial Indexes</h4>
<div class="paragraph">
<p>New in MongoDB 3.2, <a href="https://docs.mongodb.com/v3.2/core/index-partial/">partial indexes</a> only index the documents in a collection that meet a specified filter expression thereby reducing storage and maintenance costs.
A partial filter is defined using a query as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Indexes({@Index(options =
    @IndexOptions(partialFilter = "{ name : { $exists : true } }"),
    fields = {@Field(value = "name")})})
public class SomeClass {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_field_level_indexes"><a class="anchor" href="#_field_level_indexes"></a>Field Level Indexes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Field level indexing is a simpler approach to defining a basic, single key index.
These indexes are defined by applying the
<a href="javadoc/dev/morphia/annotations/Indexed.html" class="page"><code>@Indexed</code></a> annotation to a particularfield on a class.
Because the index definition is applied at the field level, the index is created using only that field and so the <a href="javadoc/dev/morphia/annotations/Field.html" class="page"><code>@Field</code></a>
annotations are unnecessary.
The options for the index are the same as defined <a href="#_index_options">above</a>.
A field level index definition would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
private class FieldIndex {
    @Id
    private ObjectId id;
    @Indexed(options = @IndexOptions(unique = true))
    private String name;
    private String color;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_text_indexing"><a class="anchor" href="#_text_indexing"></a><span id="text-indexing">Text Indexing</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia&#8217;s indexing supports MongoDB&#8217;s text indexing and search functionality as we&#8217;ve briefly seen above.
Full details can be found in the <a href="http://docs.mongodb.org/manual/core/index-text/">manual</a> but there are a few Morphia specific details to cover.
Indexed field names are validated by default but validation is disabled when an index is defined using MongoDB&#8217;s
<a href="http://docs.mongodb.org/manual/core/index-text/#text-index-wildcard"><code>$**</code></a> syntax.
This special instruction tells MongoDB to create a text index on all fields with string content in a document.
A <a href="http://docs.mongodb.org/manual/core/index-text/#compound-index">compound index</a> can be created incorporating a text index but it&#8217;s important to note there can only be one text index on a collection.</p>
</div>
<div class="paragraph">
<p>A wild card text index declaration would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Indexes(@Index(fields = @Field(value = "$**", type = TEXT)))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A collection can have at most one text index.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_collation"><a class="anchor" href="#_collation"></a>Collation</h3>
<div class="paragraph">
<p>Collation allows users to specify language-specific rules for string comparison such as rules for lettercase and accent marks.
A collation can be defined using the <code>collation()</code> property on <a href="javadoc/dev/morphia/annotations/IndexOptions.html" class="page"><code>@IndexOptions</code></a>
and takes a <a href="javadoc/dev/morphia/annotations/Collation.html" class="page"><code>@Collation</code></a> instance.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_text_searches"><a class="anchor" href="#_text_searches"></a>Text Searches</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia also supports MongoDB&#8217;s text search capabilities.
In order to execute a text search against a collection, the collection must have a <a href="http://docs.mongodb.org/manual/core/index-text/">text index</a> defined first.
Using Morphia that definition would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Indexes(@Index(fields = @Field(value = "$**", type = IndexType.TEXT)))
public static class Greeting {
    @Id
    private ObjectId id;
    private String value;
    private String language;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>$**</code> value tells MongoDB to create a text index on all the text fields in a document.
A more targeted index can be created, if desired, by explicitly listing which fields to index.
Once the index is defined, we can start querying against it like this
<a href="https://github.com/MorphiaOrg/morphia/blob/master/legacy-tests/src/test/java/dev/morphia/query/TestTextSearching.java">test</a> does:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mapper.map(Greeting.class);
datastore.ensureIndexes();

datastore.save(new Greeting("good morning", "english"),
    new Greeting("good afternoon", "english"),
    new Greeting("good night", "english"),
    new Greeting("good riddance", "english"),
    new Greeting("guten Morgen", "german"),
    new Greeting("guten Tag", "german")),
    new Greeting("gute Nacht", "german"));

List&lt;Greeting&gt; good = getDs().find(Greeting.class)
                             .filter(text("good"))
                             .execute(new FindOptions()
                                          .sort(ascending("_id")))
                             .toList();
Assert.assertEquals(4, good.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see here, we create <code>Greeting</code> objects for multiple languages.
In our test query, we&#8217;re looking for occurrences of the word "good" in any document.
Using the method <code>text()</code> found on the <code>Filters</code> class, we can then query for all instances of our search term.
We created four such documents and our query returns exactly those four.</p>
</div>
<div class="paragraph">
<p>If you would like to restrict your search to a specific language, that can also be specified as part of the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">datastore.find(Greeting.class)
         .filter(text("good")
                     .language("english"))
         .execute(new FindOptions()
                      .sort(ascending("_id")))
         .toList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are some optional parameters in addition to the language you can specify as part of your text search.
Those parameters are documented on the <a href="javadoc/dev/morphia/query/experimental/filters/TextSearchFilter.html" class="page">TextSearchFilter</a> class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_life_cycle_methods"><a class="anchor" href="#_life_cycle_methods"></a>Life Cycle Methods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are various annotations which can be used to register callbacks on certain life cycle events.
These include Pre/Post-Persist (Save), and Pre/Post-Load.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@PrePersist</code> - Called before save, it can return a <code>Document</code> in place of an empty one.</p>
</li>
<li>
<p><code>@PostPersist</code> - Called after the save call to the database</p>
</li>
<li>
<p><code>@PreLoad</code> - Called before mapping the document from the database to the entity; the Document is passed as an argument (you can add/remove/change values)</p>
</li>
<li>
<p><code>@PostLoad</code> - Called after populating the entity with the values from the document</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_examples"><a class="anchor" href="#_examples"></a>Examples</h3>
<div class="paragraph">
<p><a href="https://github.com/MorphiaOrg/morphia/blob/master/morphia/src/test/java/dev/morphia/TestQuery.java">Here</a> is a one of the test classes.</p>
</div>
<div class="paragraph">
<p>All parameters and return values are options in your implemented methods.</p>
</div>
<div class="sect3">
<h4 id="_example"><a class="anchor" href="#_example"></a>Example</h4>
<div class="paragraph">
<p>Here is a simple example of an entity that always saves the Date it was last updated.
Alternatively, the resulting serialized form can be passed back in just prior to sending the document to the database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class BankAccount {
  @Id
  String id;
  Date lastUpdated = new Date();

  @PrePersist
  public void trackUpdate() {
    lastUpdated = new Date();
  }

  @PrePersist
  public void prePersist( Document document) {
    // perform operations on serialized form of the entity
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_entitylisteners"><a class="anchor" href="#_entitylisteners"></a>EntityListeners</h3>
<div class="paragraph">
<p>If your application has more generalized life cycle events, these methods can be stored on classes external to your model.
For example&#8217;s sake, let&#8217;s assume there&#8217;s a need to digitally sign all documents before storing it in the database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EntityListeners(DigitalSigner.class)
public class BankAccount {
  @Id
  String id;
  Date lastUpdated = new Date();
}

class DigitalSigner {
  @PrePersist
  void prePersist( Object entity, Document document) {
     document.put("signature", sign(document));
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>No Delete Support</strong> Because deletes are usually done with queries there is no way to support a Delete lifecycle event.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_schema_validation"><a class="anchor" href="#_schema_validation"></a>Schema Validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Morphia provides annotations that allow developers to define document validations for a collection to be defined alongside the other mapping data on an entity&#8217;s source.  <a href="http://docs.mongodb.org/manual/core/schema-validation/">Schema validation</a>provides the capability to perform schema validation during updates and insertions.
Validation rules are on a per-collection basis and can be defined via annotations just like indexes are.</p>
</div>
<div class="paragraph">
<p>Below we have a basic entity definition.
Note the new annotation <a href="javadoc/dev/morphia/annotations/Validation.html" class="page">@Validation</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity("validation")
@Validation("{ number : { $gt : 10 } }")
public class DocumentValidation {
    @Id
    private ObjectId id;
    private String string;
    private int number;
    private Date date;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, only one value is supplied to the annotation.
This string value is the query that will be used to match against any new documents or updated documents.
Should this query fail to match the new document, validation will fail on the document and it will be rejected.
In addition to the required query, there are two other values that can be configured based on your needs:  <code>level</code> with a default of <code>STRICT</code> and <code>action</code> with a default of <code>ERROR</code>.
A <code>MODERATE</code> validation level does not apply rules to updates on existing invalid documents.
An <code>action</code> setting of <code>WARN</code> will merely log any validation violations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transactions"><a class="anchor" href="#_transactions"></a>Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Starting with MongoDB version 4.0, multi-document transactions are now supported on replica sets.
Morphia 2.0 introduced a simple mechanism to access this functionality.
Morphia 2.0 added the methods <code>withTransaction(MorphiaTransaction&lt;T&gt; transaction)</code> and
<code>withTransaction(ClientSessionOptions options, MorphiaTransaction&lt;T&gt; transaction)</code> allowing for the execution of logic scoped to a transaction.</p>
</div>
<div class="paragraph">
<p>The API is designed to work with Java 8&#8217;s lambda syntax for the most convenience.
In this example, let&#8217;s assume we&#8217;re building a shopping site.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">User account = datastore.withTransaction((session) -&gt; {
    User user = new User("jimbo", "jimhalpert@dundermifflin.com");
    user.setHomeAddress(new Address("123 Paper Lane", "Scranton", "PA", "18510"));

    return session.save(user);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this simple example, we&#8217;re starting with our standard <code>Datastore</code> and calling <code>withTransaction()</code>.
The lambda we&#8217;re passing in executes all with the scope of a single transaction.
You&#8217;ll note the single parameter passed in is a <code>MorphiaSession</code>.
This is actually a <code>Datastore</code> but it has been bound to a session.
Any changes to be made within the transaction should be made using this
<code>session</code> reference.
Once the lambda returns, the transaction is automatically committed and the session closed.
If you need access to server session or the transaction, there are methods on <code>MorphiaSession</code> to return either of those.</p>
</div>
<div class="paragraph">
<p>Of course, it&#8217;s not always possible to wrap things up neatly inside a lambda so let&#8217;s take a look at more hands on approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MorphiaSession session = datastore.startSession();
session.startTransaction();
User account = new User("jimbo", "jimhalpert@dundermifflin.com");
user.setHomeAddress(new Address("123 Paper Lane", "Scranton", "PA", "18510"));
session.save(user);
session.commitTransaction();
session.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is essentially the same logic as above but now we&#8217;re manually managing the transactional boundaries.  <code>MorphiaSession</code> is also
<code>AutoCloseable</code> so you could wrap the entire block in a <code>try-with-resources</code> block and let that manage the session boundary for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try(MorphiaSession session = datastore.startSession()) {
    session.startTransaction();
    User account = new User("jimbo", "jimhalpert@dundermifflin.com");
    user.setHomeAddress(new Address("123 Paper Lane", "Scranton", "PA", "18510"));
    session.save(user);
    session.commitTransaction();
}</code></pre>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<!--
<footer class="footer">
    <p>Copyright (C) 2020-2020
</footer>
-->
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
