<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Morphia</title>
    <link>/1.5.8/</link>
    <description>Recent content on Morphia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Mar 2015 15:36:56 +0000</lastBuildDate>
    
	<atom:link href="/1.5.8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Issues &amp; Help</title>
      <link>/1.5.8/issues-help/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/1.5.8/issues-help/</guid>
      <description>Issues &amp;amp; Help We are lucky to have a vibrant MongoDB Java community with lots of varying experience of using Morphia. We often find the quickest way to get support for general questions is through the Morphia google group, mongodb-user google group, or through stackoverflow. Please also refer to our own support channels documentation. If you have a question or think you&amp;rsquo;ve encountered a bug, the mailing list is the place to start.</description>
    </item>
    
    <item>
      <title>Annotations</title>
      <link>/1.5.8/guides/annotations/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/1.5.8/guides/annotations/</guid>
      <description>Below is a list of all the annotations and a brief description of how to use them.
Indexes Indexes can be defined on each field directly for single field indexing or at the class level for compund indexes. To see the next few annotations in context, please refer to TestIndexCollections.java or TestIndexed.java in the Morphia source.
Index The @Index documentation can be found here. There are two pieces to this annotation that are mutually exclusive.</description>
    </item>
    
    <item>
      <title>Installation Guide</title>
      <link>/1.5.8/getting-started/installation-guide/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/1.5.8/getting-started/installation-guide/</guid>
      <description>The recommended way to get started using Morphia in your project is with a dependency management system.
&amp;lt;dependencies&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;dev.morphia.morphia&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;core&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.5.8&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;dependencies {compile &#39;dev.morphia.morphia:core:1.5.8&#39;}</description>
    </item>
    
    <item>
      <title>Quick Tour</title>
      <link>/1.5.8/getting-started/quick-tour/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/1.5.8/getting-started/quick-tour/</guid>
      <description>Morphia wraps the MongoDB Java driver so some level of familiarity with using the driver can be helpful. Morphia does its best to abstract much of that away but if something is confusing, please consult the Java driver [documentation](http://mongodb.github .io/mongo-java-driver/) as well.
The following code snippets come from the QuickTour.java example code that can be found with the Morphia source.
Setting up Morphia The following example shows how to create the initial Morphia instance.</description>
    </item>
    
    <item>
      <title>Aggregation</title>
      <link>/1.5.8/guides/aggregation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/aggregation/</guid>
      <description>The aggregation framework in MongoDB allows you to define a series (called a pipeline) of operations (called stages) against the data in a collection. These pipelines can be used for analytics or they can be used to convert your data from one form to another. This guide will not go in to the details of how aggregation works, however. The official MongoDB documentation has extensive tutorials on such details. Rather, this guide will focus on the Morphia API.</description>
    </item>
    
    <item>
      <title>Indexing</title>
      <link>/1.5.8/guides/indexing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/indexing/</guid>
      <description>Morphia provides annotations that allow developers to define indexes for a collection to be defined alongside the other mapping data on an entity&amp;rsquo;s source. In addition to the familiar ascending/descending index types, Morphia and MongoDB support TTL, text, and geospatial indexes. When defining text indexes there are certain restrictions which will be covered below. Full details for all these types are available in the manual.
There are two ways to define indexes: at the class level and at the field level.</description>
    </item>
    
    <item>
      <title>JRebel</title>
      <link>/1.5.8/guides/jrebel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/jrebel/</guid>
      <description>This is a simple extension to Morphia to allow classes to be re-mapped once they are reloaded by JRebel.
Prerequisites Of course you need to run JRebel (http://zeroturnaround.com) for this extension to be useful. On top of that, you need to tell JRebel about the Plugin. In order to do that, add the following two new Elements to the VM startup command:
-Drebel.morphia=true -Drebel.plugins=/path/to/morphia-jrebel-plug-1.0-SNAPSHOT.jarIf youÂ´re using Eclipse with the JRebel Plugin this can be skipped and instead configured in the Agent Settings GUI.</description>
    </item>
    
    <item>
      <title>Life Cycle Methods</title>
      <link>/1.5.8/guides/lifecyclemethods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/lifecyclemethods/</guid>
      <description>There are various annotations which can be used to register callbacks on certain life cycle events. These include Pre/Post-Persist (Save) , and Pre/Post-Load.
 @PrePersist - Called before save, it can return a DBObject in place of an empty one. @PreSave - Called right before DBCollection.save() is called. Changes made to the entity will not be persisted; the DBObject can be passed as an argument (you can add/remove/change values) @PostPersist - Called after the save call to the database @PreLoad - Called before mapping the document from the database to the entity; the DBObject is passed as an argument (you can add/remove/change values) @PostLoad - Called after populating the entity with the values from the document  See the annotations guide for a full list of the annotations supported.</description>
    </item>
    
    <item>
      <title>Migration Guide</title>
      <link>/1.5.8/getting-started/migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/getting-started/migration/</guid>
      <description>Migrating to 1.5  Indexing of @Embedded fields is being deprecated in favor of declaring all indexes at the top level @Entity level. The new index definitions just need to use the dotted path names to recreate these indexes. To turn off the warning in the logs about embedded indexing, simply pass false to MapperOptions#setDisableEmbeddedIndexes. Query#asList() is deprecated. Usages should be updated to use find().toList() instead.  </description>
    </item>
    
    <item>
      <title>Querying</title>
      <link>/1.5.8/guides/querying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/querying/</guid>
      <description>Morphia offers a fluent API with which to build up a query and map the results back to instances of your entity classes. It attempts to provide as much type safety and validation as possible. To this end, Morphia offers the Query&amp;lt;T&amp;gt; class which can be parameterized to the type of your entity.
Creating a Query The Datastore is the key class when using Morphia. Virtually all operations begin with the Datastore.</description>
    </item>
    
    <item>
      <title>References</title>
      <link>/1.5.8/guides/references/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/references/</guid>
      <description>Morphia supports two styles of defining references: the @Reference annotation and the experimental MorphiaReference. The annotation based approach is discussed here. This guide will cover the wrapper based approach.
This API is experimental. Its implementation and API subject to change based on user feedback. However, users are encouraged to experiment with the API and provide as much feedback as possible both positive and negative as this will likely be the approach used going forward.</description>
    </item>
    
    <item>
      <title>Schema Validation</title>
      <link>/1.5.8/guides/schemavalidation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/schemavalidation/</guid>
      <description>Morphia provides annotations that allow developers to define document validations for a collection to be defined alongside the other mapping data on an entity&amp;rsquo;s source. Schema validationprovides the capability to perform schema validation during updates and insertions. Validation rules are on a per-collection basis and can be defined via annotations just like indexes are.
Below we have a basic entity definition. Note the new annotation @Validation.
@Entity(&amp;#34;validation&amp;#34;)@Validation(&amp;#34;{ number : { $gt : 10 } }&amp;#34;)public class DocumentValidation {@Idprivate ObjectId id;private String string;private int number;private Date date;.</description>
    </item>
    
    <item>
      <title>Updating</title>
      <link>/1.5.8/guides/updating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/updating/</guid>
      <description>There are two basic ways to update your data: insert/save a whole Entity or issue an update operation.
Updating (on the server) The update method on Datastore is used to issue a command to the server to change existing documents. The effects of the update command are defined via UpdateOperations methods.
The Field Expression The field expression, used by all update operations, can be either a single field name or any dot-notation form (for embedded elements).</description>
    </item>
    
    <item>
      <title>Validation Extension</title>
      <link>/1.5.8/guides/validationextension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1.5.8/guides/validationextension/</guid>
      <description>This is a simple extension to Morphia to process JSR 303 Validation Annotations.
Using Add this at the start of your application (or wherever you create your morphia instances).
new ValidationExtension(morphia);Example Here is a simple example using (as an example) Hibernate validation:
...import org.hibernate.validator.constraints.Email;...@Entitypublic class Userlike {@Id ObjectId id;@Email String email;}Implementation This is a lightweight wrapper around the JSR 303 API. It installs a simple global entity interceptor which listens to all life cycle methods needed for validation.</description>
    </item>
    
  </channel>
</rss>